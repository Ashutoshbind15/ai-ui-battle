import { eq, isNull, and, desc, sql, count } from "drizzle-orm";
import { db } from "../db";
import { prompts } from "../db/schema";
import { batches, containerMetadata, sessions, turns } from "../db/schema";

type ModelConfig = {
  providerId: string;
  modelId: string;
};

export type SessionStatus =
  | "uninitialized"
  | "setup_pending"
  | "setup_failed"
  | "ready"
  | "prompting"
  | "completed"
  | "failed";

export type DevServerStatus = "stopped" | "starting" | "running" | "error";

// Port range for dev servers
const PORT_RANGE_START = 5174;
const PORT_RANGE_END = 5200;

const autoGeneratedName = () => {
  const adjectives = [
    "Amazing",
    "Awesome",
    "Fantastic",
    "Incredible",
    "Super",
    "Wonderful",
    "Brilliant",
    "Exceptional",
    "Outstanding",
    "Marvelous",
  ];
  const nouns = ["comparison", "run", "test"];
  return `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${
    nouns[Math.floor(Math.random() * nouns.length)]
  }`;
};

// ==================== PORT MANAGEMENT ====================

// Get all ports currently in use (assigned to sessions)
export const getUsedPorts = async (): Promise<number[]> => {
  const usedSessions = await db
    .select({ port: sessions.port })
    .from(sessions)
    .where(sql`${sessions.port} IS NOT NULL`);
  return usedSessions.map((s) => s.port).filter((p): p is number => p !== null);
};

// Get available ports from the range
export const getAvailablePorts = async (): Promise<number[]> => {
  const usedPorts = await getUsedPorts();
  const availablePorts: number[] = [];
  for (let port = PORT_RANGE_START; port <= PORT_RANGE_END; port++) {
    if (!usedPorts.includes(port)) {
      availablePorts.push(port);
    }
  }
  return availablePorts;
};

// Reserve a port for a session (atomic operation to prevent race conditions)
// Note: This only reserves the port, it does NOT start or change devServerStatus
export const reservePort = async (
  sessionId: number,
): Promise<number | null> => {
  const availablePorts = await getAvailablePorts();
  if (availablePorts.length === 0) {
    return null;
  }

  const port = availablePorts[0];

  // Try to assign the port - this could fail if another session grabbed it
  const [updated] = await db
    .update(sessions)
    .set({ port })
    .where(and(eq(sessions.id, sessionId), isNull(sessions.port)))
    .returning();

  if (!updated) {
    // Session already has a port or doesn't exist
    const [existing] = await db
      .select()
      .from(sessions)
      .where(eq(sessions.id, sessionId));
    return existing?.port ?? null;
  }

  return port ?? null;
};

// Release a port (separate from dev server status management)
export const releasePort = async (sessionId: number): Promise<void> => {
  await db
    .update(sessions)
    .set({ port: null })
    .where(eq(sessions.id, sessionId));
};

// ==================== SESSION MANAGEMENT ====================

// Creates session in setup_pending state (no opencode session yet)
export const createSession = async (
  providerId: string,
  modelId: string,
  batchId: number,
  directory: string,
) => {
  const [session] = await db
    .insert(sessions)
    .values({
      providerId,
      modelId,
      batchId,
      directory,
    })
    .returning();
  if (!session) {
    throw new Error("Failed to create session");
  }
  return session;
};

// Get a session by ID with batch prompt
export const getSession = async (sessionId: number) => {
  const [result] = await db
    .select({
      session: sessions,
      prompt: batches.prompt,
    })
    .from(sessions)
    .leftJoin(batches, eq(sessions.batchId, batches.id))
    .where(eq(sessions.id, sessionId));

  if (!result) {
    return null;
  }

  return {
    ...result.session,
    prompt: result.prompt,
  };
};

// Get all running sessions (dev server running)
export const getRunningSessions = async () => {
  const result = await db
    .select({
      session: sessions,
      batchName: batches.name,
    })
    .from(sessions)
    .leftJoin(batches, eq(sessions.batchId, batches.id))
    .where(eq(sessions.devServerStatus, "running"));

  return result.map((r) => ({
    ...r.session,
    batchName: r.batchName,
  }));
};

// Update dev server status
export const updateDevServerStatus = async (
  sessionId: number,
  status: DevServerStatus,
  pid?: number | null,
) => {
  const [session] = await db
    .update(sessions)
    .set({
      devServerStatus: status,
      ...(pid !== undefined && { devServerPid: pid }),
    })
    .where(eq(sessions.id, sessionId))
    .returning();
  return session;
};

// Update session status (and optionally error)
export const updateSessionStatus = async (
  sessionId: number,
  status: SessionStatus,
  error?: string,
) => {
  const [session] = await db
    .update(sessions)
    .set({
      status,
      ...(error && { error }),
    })
    .where(eq(sessions.id, sessionId))
    .returning();
  if (!session) {
    throw new Error("Failed to update session");
  }
  return session;
};

// Set opencodeSessionId for a session (separate from status updates)
export const setOpencodeSessionId = async (
  sessionId: number,
  opencodeSessionId: string,
) => {
  const [session] = await db
    .update(sessions)
    .set({ opencodeSessionId })
    .where(eq(sessions.id, sessionId))
    .returning();
  if (!session) {
    throw new Error("Failed to update session");
  }
  return session;
};

export const createTurn = async (sessionId: number, currentTime: Date) => {
  const [turn] = await db
    .insert(turns)
    .values({
      sessionId,
      startTime: currentTime,
    })
    .returning();
  if (!turn) {
    throw new Error("Failed to create turn");
  }
  return turn;
};

const getTurn = async (sessionId: number) => {
  const [turn] = await db
    .select()
    .from(turns)
    .where(eq(turns.sessionId, sessionId))
    .limit(1);
  if (!turn) {
    throw new Error("Turn not found");
  }
  return turn;
};

// for now, we're having single turns, on multi-turn support, update accordingly
export const updateSingularTurn = async (
  sessionId: number,
  status: "pending" | "completed" | "failed",
  error?: string,
  endTime?: Date,
) => {
  const [turn] = await db
    .update(turns)
    .set({
      status,
      error,
      endTime,
    })
    .where(eq(turns.sessionId, sessionId))
    .returning();
  if (!turn) {
    throw new Error("Failed to update turn");
  }
  return turn;
};

// ==================== BATCH MANAGEMENT ====================

export const createBatch = async (
  modelConfigs: ModelConfig[],
  prompt?: string,
) => {
  const name = autoGeneratedName();
  const [batch] = await db.insert(batches).values({ name, prompt }).returning();
  if (!batch) {
    throw new Error("Failed to create batch");
  }

  return { id: batch.id, name: batch.name };
};

// Get all batches with session count only (slimmed down for list view)
export const getAllBatches = async () => {
  const result = await db
    .select({
      id: batches.id,
      name: batches.name,
      prompt: batches.prompt,
      createdAt: batches.createdAt,
      sessionCount: count(sessions.id),
    })
    .from(batches)
    .leftJoin(sessions, eq(batches.id, sessions.batchId))
    .groupBy(batches.id)
    .orderBy(desc(batches.createdAt));

  return result.map((batch) => ({
    id: batch.id,
    name: batch.name,
    prompt: batch.prompt,
    createdAt: batch.createdAt,
    sessionCount: Number(batch.sessionCount || 0),
  }));
};

// Get a batch by ID with sessions (optimized with JOIN)
export const getBatchById = async (batchId: number) => {
  const result = await db
    .select({
      // Batch fields
      batchId: batches.id,
      batchName: batches.name,
      batchPrompt: batches.prompt,
      batchCreatedAt: batches.createdAt,
      // Session fields (only what's actually used in Runs.tsx)
      sessionId: sessions.id,
      modelId: sessions.modelId,
      providerId: sessions.providerId,
      status: sessions.status,
      error: sessions.error,
      port: sessions.port,
      devServerStatus: sessions.devServerStatus,
    })
    .from(batches)
    .leftJoin(sessions, eq(sessions.batchId, batches.id))
    .where(eq(batches.id, batchId));

  if (result.length === 0) {
    return null;
  }

  // First row contains batch info (all rows have the same batch data)
  const firstRow = result[0]!;
  const batch = {
    id: firstRow.batchId,
    name: firstRow.batchName,
    prompt: firstRow.batchPrompt,
    createdAt: firstRow.batchCreatedAt,
    sessions: [] as Array<{
      id: number;
      batchId: number | null;
      opencodeSessionId: string | null;
      directory: string;
      modelId: string;
      providerId: string;
      starterTemplate: string;
      status: SessionStatus;
      error: string | null;
      port: number | null;
      devServerStatus: DevServerStatus;
      devServerPid: number | null;
    }>,
  };

  // Collect sessions from all rows
  for (const row of result) {
    if (
      row.sessionId !== null &&
      row.modelId !== null &&
      row.providerId !== null &&
      row.status !== null &&
      row.devServerStatus !== null
    ) {
      batch.sessions.push({
        id: row.sessionId,
        batchId: batchId, // Use batchId from parameter
        opencodeSessionId: null, // Not used in UI
        directory: "", // Not used in UI
        modelId: row.modelId,
        providerId: row.providerId,
        starterTemplate: "", // Not used in UI
        status: row.status as SessionStatus,
        error: row.error,
        port: row.port,
        devServerStatus: row.devServerStatus as DevServerStatus,
        devServerPid: null, // Not used in UI
      });
    }
  }

  return batch;
};

// ==================== PROMPT MANAGEMENT ====================

export const getAllPrompts = async () => {
  const result = await db
    .select()
    .from(prompts)
    .orderBy(desc(prompts.isDefault), desc(prompts.createdAt));
  return result;
};

export const createPrompt = async (
  title: string,
  description: string,
  isDefault: boolean = false,
) => {
  const [prompt] = await db
    .insert(prompts)
    .values({ title, description, isDefault })
    .returning();
  if (!prompt) {
    throw new Error("Failed to create prompt");
  }
  return prompt;
};

export const updatePrompt = async (
  promptId: number,
  title: string,
  description: string,
) => {
  const [prompt] = await db
    .update(prompts)
    .set({ title, description, updatedAt: new Date() })
    .where(eq(prompts.id, promptId))
    .returning();
  if (!prompt) {
    throw new Error("Failed to update prompt");
  }
  return prompt;
};

export const deletePrompt = async (promptId: number) => {
  await db.delete(prompts).where(eq(prompts.id, promptId));
};

export const findSessionContainer = async (sessionId: number) => {
  const [container] = await db
    .select()
    .from(containerMetadata)
    .where(eq(containerMetadata.sessionId, sessionId));
  return container;
};
